"""
screenwriter.py - The Creative AI

Uses Gemini Pro to generate unique "What if...?" alternative history scenarios.
Outputs: premise, location, and 3 timeline stages with descriptions.
"""

import os
import json
from datetime import datetime
from pathlib import Path
from typing import Optional
from dataclasses import dataclass, field, asdict
from helpers.manager import load_prompt

import yaml
from google import genai
from dotenv import load_dotenv

# Load environment variables
load_dotenv(override=True)


# Get project root directory
PROJECT_ROOT = Path(__file__).parent.parent





def load_model_config() -> dict:
    """Load model configuration from YAML file."""
    config_path = PROJECT_ROOT / "configs" / "model_config.yaml"
    if config_path.exists():
        with open(config_path, 'r', encoding='utf-8') as f:
            return yaml.safe_load(f)
    # Default config if file doesn't exist
    return {
        "gemini": {"model": "gemini-2.0-flash", "screenwriter": {"temperature": 0.95}}
    }


@dataclass
class StageData:
    """Data for a single timeline stage."""
    year: str
    label: str
    description: str
    mood: str
    image_prompt: str = ""  # Generated by Prompt Improver
    audio_prompt: str = ""  # Generated by Prompt Improver


@dataclass
class Scenario:
    """Complete scenario data generated by the screenwriter."""
    id: str
    premise: str
    location_name: str
    location_prompt: str
    stage_1: StageData
    stage_2: StageData
    stage_3: StageData
    title: str = ""  # Rage-bait style short title
    status: str = "PENDING"
    created_at: str = ""
    video_url: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.id:
            self.id = f"scenario_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
    
    def to_dict(self) -> dict:
        """Convert to dictionary for Sheets storage."""
        return {
            "id": self.id,
            "title": self.title,
            "premise": self.premise,
            "location_name": self.location_name,
            "location_prompt": self.location_prompt,
            "stage_1_year": self.stage_1.year,
            "stage_1_label": self.stage_1.label,
            "stage_1_description": self.stage_1.description,
            "stage_1_mood": self.stage_1.mood,
            "stage_1_image_prompt": self.stage_1.image_prompt,
            "stage_1_audio_prompt": self.stage_1.audio_prompt,
            "stage_2_year": self.stage_2.year,
            "stage_2_label": self.stage_2.label,
            "stage_2_description": self.stage_2.description,
            "stage_2_mood": self.stage_2.mood,
            "stage_2_image_prompt": self.stage_2.image_prompt,
            "stage_2_audio_prompt": self.stage_2.audio_prompt,
            "stage_3_year": self.stage_3.year,
            "stage_3_label": self.stage_3.label,
            "stage_3_description": self.stage_3.description,
            "stage_3_mood": self.stage_3.mood,
            "stage_3_image_prompt": self.stage_3.image_prompt,
            "stage_3_audio_prompt": self.stage_3.audio_prompt,
            "status": self.status,
            "created_at": self.created_at,
            "video_url": self.video_url,
        }


class Screenwriter:
    """Generates alternative history scenarios using Gemini."""
    
    def __init__(self, api_key: Optional[str] = None):
        """Initialize with Gemini API key."""
        self.api_key = api_key or os.getenv("GOOGLE_API_KEY")
        if not self.api_key:
            raise ValueError("GOOGLE_API_KEY not found in environment")
        
        # Load model config
        self.config = load_model_config()
        gemini_config = self.config.get("gemini", {})
        self.model_name = gemini_config.get("model", "gemini-2.0-flash")
        self.temperature = gemini_config.get("screenwriter", {}).get("temperature", 0.95)
        
        # Initialize the new genai Client
        self.client = genai.Client(api_key=self.api_key)
        
        # Load prompt from file
        try:
            self.base_prompt = load_prompt("screenwriter")
        except FileNotFoundError:
            # Fallback to inline prompt if file doesn't exist
            self.base_prompt = self._get_default_prompt()
    
    def _get_default_prompt(self) -> str:
        """Fallback prompt if file not found."""
        return """You are a creative screenwriter for alternative history videos.
Generate a unique scenario with premise, location, and 3 stages.
Respond with valid JSON."""
    
    def _find_overused_countries(self, premises: list, threshold: int = 3) -> list:
        """
        Analyze existing premises to find countries that appear too frequently.
        
        Args:
            premises: List of existing premise strings
            threshold: Number of mentions before a country is considered overused
            
        Returns:
            List of overused country names
        """
        # Common countries to track
        countries = [
            "China", "Russia", "USA", "America", "United States",
            "North Korea", "Iran", "Japan", "Germany", "UK", "Britain",
            "France", "India", "Pakistan", "Turkey", "Cuba", "Venezuela",
            "Australia", "South Korea", "Israel", "Saudi Arabia"
        ]
        
        # Count mentions
        counts = {}
        all_text = " ".join(premises).lower()
        for country in countries:
            count = all_text.count(country.lower())
            if count > 0:
                # Normalize USA/America/United States
                if country in ["USA", "America", "United States"]:
                    key = "USA"
                elif country in ["UK", "Britain"]:
                    key = "UK"
                else:
                    key = country
                counts[key] = counts.get(key, 0) + count
        
        # Return countries that exceed threshold
        return [c for c, n in counts.items() if n >= threshold]
    
    def generate_scenario(self, topic_hint: Optional[str] = None, 
                          avoid_premises: Optional[list] = None) -> Scenario:
        """
        Generate a new alternative history scenario.
        
        Args:
            topic_hint: Optional hint to guide the topic (e.g., "technology", "war", "nature")
            avoid_premises: List of existing premises to avoid generating duplicates
            
        Returns:
            Scenario object with all data
        """
        # Build the prompt from external file
        prompt = self.base_prompt
        if topic_hint:
            prompt += f"\n\nTopic hint: Focus on themes related to '{topic_hint}'"
        
        # Add existing premises to avoid
        if avoid_premises:
            prompt += "\n\nâš ï¸ CRITICAL: Do NOT generate any scenarios about these topics (already used):\n"
            for p in avoid_premises[:15]:  # Limit to 15 to not overwhelm context
                prompt += f"  - {p}\n"
            prompt += "\nGenerate something COMPLETELY DIFFERENT from the above topics."
            
            # Analyze for overused countries and add avoidance instruction
            overused = self._find_overused_countries(avoid_premises)
            if overused:
                prompt += f"\n\nðŸš« DIVERSITY REQUIREMENT: The following countries appear too frequently. Use a DIFFERENT country as the aggressor: {', '.join(overused)}"
        
        # Add today's date for context
        today = datetime.now().strftime("%B %d")
        prompt += f"\n\nToday's date: {today}. You may optionally tie the scenario to historical events near this date."
        
        # Generate using new Client API
        print("ðŸŽ¬ Screenwriter generating scenario...")
        response = self.client.models.generate_content(
            model=self.model_name,
            contents=prompt,
            config={
                'temperature': self.temperature,
                'response_mime_type': 'application/json'
            }
        )
        
        # Parse response
        try:
            data = json.loads(response.text)
        except json.JSONDecodeError as e:
            raise ValueError(f"Failed to parse Gemini response as JSON: {e}\nResponse: {response.text}")
        
        # Build Scenario object
        scenario = Scenario(
            id="",  # Will be auto-generated
            title=data.get("title", ""),
            premise=data["premise"],
            location_name=data["location_name"],
            location_prompt=data["location_prompt"],
            stage_1=StageData(**data["stage_1"]),
            stage_2=StageData(**data["stage_2"]),
            stage_3=StageData(**data["stage_3"]),
        )
        
        print(f"âœ… Generated: {scenario.premise}")
        print(f"   ðŸ“ Location: {scenario.location_name}")
        
        return scenario


def generate_scenario(topic_hint: Optional[str] = None, 
                     avoid_premises: Optional[list] = None) -> Scenario:
    """Convenience function to generate a scenario."""
    writer = Screenwriter()
    return writer.generate_scenario(topic_hint, avoid_premises)


if __name__ == "__main__":
    # Test the screenwriter
    print("\n" + "=" * 50)
    print("ðŸŽ¬ Testing Screenwriter")
    print("=" * 50)
    
    scenario = generate_scenario()
    
    print("\nðŸ“‹ Full Scenario:")
    print(json.dumps(scenario.to_dict(), indent=2))
